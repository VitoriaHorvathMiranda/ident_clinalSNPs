---
title: "Relatório"
author: "Vitória"
date: '2023-06-12'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(tidyverse)
library(qvalue)
library(knitr)
library(maptools)
library(mapdata)
library(ggrepel)
```

# Resumo do Projeto Inicial

Sequenciamos, com pool-seq, populações de D. melanogaster ao longo da costa leste dos EUA em 1997 e em 2009/2010. Vamos comparar os padrões clinais nos dois períodos.

```{r mapa, echo = FALSE, warning=FALSE, message=FALSE}
metadata <- read_tsv("/home/vitoria/time_clines/data/meta/seq_metadata.tsv")
pop_info <- metadata %>%
  select(population, collection_year:longitude) %>%
  mutate(collection_year = case_when(collection_year == 1997 ~ "1997",
                                     collection_year == 2009 ~ "2009/2010",
                                     collection_year == 2010 ~ "2009/2010",
                                     collection_year == 2017 ~ "2017")) %>%
  mutate(population = str_extract(population, "[A-Z]{3}"))

usa <- map_data("state")
canada <- map_data("worldHires", "Canada")
mexico <- map_data("worldHires", "Mexico")

ggplot() + 
  geom_polygon(data = usa, aes(long, lat, group = group), 
                                  fill = "gray", 
                                  color="black") +
  geom_polygon(data = canada,
               aes(long, lat, group = group), 
               fill = "gray", 
               color="black") +
  coord_fixed(xlim = c(-85, -65),
              ylim = c(25, 50), 
              ratio = 1.2) +
  geom_point(data = pop_info,
             aes(longitude, latitude),
             #color = "red",
             size = 2.5) +
  geom_label_repel(data = pop_info, 
                       aes(longitude, latitude, label = population),
                       size = 2) +
  labs(x = "Longitude", y = "Latitude") +
  facet_wrap(.~collection_year) +
  theme_bw(base_size = 17)
```

# 
## SNP Calling

Depois de montar e mapear as sequencias (etapas que estão descritas [aqui]()), chamamos os SNPs com o programa [PoolSNP](https://github.com/capoony/PoolSNP), que foi feito para chamar SNPs sequenciados por pool-seq. Ele aceita varias populações como input e devolve as frequências alélicas de cada população. É um programa bastante prático, porque possibilita que limites mínimos de profundidade e qualidade sejam estabelecidos. Esses limites valem para todas as populações, assim, temos a garantia que estamos comparando regiões que podem ser comparadas.Por exemplo, ele não consideraria SNPs que nas populações de  2009/2010 estão com boa qualidade, mas que em 1997 estão com a profundidade de leitura muito baixa. Outros parâmetros incluem o mínimo de reads que o alelo alternativo deve ter para ser considerado polimórfico e a frequência mínima que o SNP deve ter (esses dois parâmetros são calculados com base em todas as populações). Além do vcf com todos os SNPs identificados, PoolSNP também retorna um output com todas as posições que não foram chamadas porque não passaram no controle de qualidade.

Rodamos o PoolSNP com os seguintes parâmetros:

```{bash SNPcall, eval=F, echo=T}
bash /home/vitoria/PoolSNP/PoolSNP.sh\
    mpileup={input.mpileup}\
    reference={input.ref}\
    names=CMD97B,WVT97,MFL97,RVA97,SVT09,CMD10,SNC10,JFL10,CMA97,HMA09,HMA17,MCT09,MCT17,MCT97\
    max-cov=0.98\
    min-cov=15\
    min-count=5\
    min-freq=0.001\
    miss-frac=0.1\
    jobs=24\
    BS=1\
    base-quality=20\
    allsites=0\
    output={params.outdir}

``` 

Retiramos a população ESC97 por causa da baixa qualidade do sequenciamento.

O vcf criado ficou assim: 

```{bash viewVCF, echo=FALSE}

cat "/dados/time_clines/data/seqs/calls/PoolSNP_no_ESC97_mincount5_minfreq0.001_cov15.vcf" | grep -v "##" | head

```

Filtramos o VCF de forma a incluir apenas os SNPs presentes nos cromossomso 2L, 2R, 3L, 3R e X. Também excluimos os SNPs que estavam a 5bp de indels e removemos regiões repetitivas usando os arquivos do repeatmasker.org. 

## Identificação dos SNPs Clinais

Para identificar os SNPs clinais era preciso testar a clinalidade de cada SNP em cada período. Para isso, optamos por um GLM com função de ligação binomial das frequências alélicas contra latitude pesado para a cobertura e número de cromossomos nas amostras (mesmo modelo escolhido no trabalho do Murillo). 

### Número efetivo de Cromossomos

O número efetivo de cromossomos (usado para pesar os GLMs) foi calculado da sequinte forma:
```{r NE_math, eval=F, echo=T}
freqs[, NE := ((1/depth) + (1/n_chrom))^-1]
```

Onde ```depth``` é a profundidade de leitura daquele site naquela população e ```n_chrom``` é o número de cromossomos (nº de moscas x2) no pool. O número de cromossomos amostrados em cada população estava na tabela de metadados e a profundidade de leitura foi extraída do vcf, os detalhes estão no script [n_chrom]().

```{r ne_table, echo=FALSE}
kable(fread("/dados/time_clines/data/seqs/align/NE_no_ESC97_mincount5_minfreq0.001_cov15.tsv", nrows = 10))
```

### GLM

Antes de correr o GLM, as populações de 1997 e 2009/2010 foram separadas em dois arquivos diferentes. Todos os SNPs cuja frequência era zero em todas as população de uma dada época foram removidos. Os GLMs foram calculados com o script [glm_script.R](). Basicamente, isso foi feito da seguinte forma:

```{r glm_formula, eval=F, echo=T, warning=FALSE}
nested_snps[, models := purrr::map(data, ~ glm(freq~latitude, 
                                               weights = NE,
                                               data = .x,
                                               family = binomial()))]
```

```{r glm_nested_table, echo=FALSE, warning=FALSE}
NE_table <- fread(file = "/dados/time_clines/output/SNPs/joined97_2L_no_ESC97_mincount5_minfreq0.001_cov15.tsv")
setnames(NE_table, colnames(NE_table), c("population", "latitude", "n_chrom", 
"CHROM", "POS", "REF", "ALT", "depth", "freq","NE"))
NE_table <- NE_table[CHROM == "2L",]
NE_table[, position2 := paste(CHROM, POS, sep = ":")]
NE_table <- NE_table[, !c("CHROM", "POS")]

group_nest_dt <- function(dt, ..., .key = "data"){
  stopifnot(is.data.table(dt))
  by <- substitute(list(...))
  dt <- dt[, list(list(.SD)), by = eval(by)]
  setnames(dt, old = "V1", new = .key)
  dt
}

nested_snps <- NE_table[,group_nest_dt(.SD, position2)]

nested_snps <- nested_snps[1:10,]
nested_snps[, models := purrr::map(data, ~ glm(freq~latitude, 
                                               weights = NE,
                                               data = .x,
                                               family = binomial()))]

nested_snps
```

olhando para um modelo:

```{r glm_models, echo=FALSE, warning=FALSE}
pluck(nested_snps[[3]]) %>% pluck(1)

nested_snps[, summary := purrr::map(models, 
                                        ~summary(.x))]
pluck(nested_snps[[4]]) %>% pluck(1)
```

Então extrai o coeficiente de inclinação e o p-valor associado ao coeficiente de inclinação de cada glm:
```{r, echo=FALSE, warning=FALSE}
#gets lat coefficient
nested_snps[, coefficients := purrr::map_dbl(models, ~coef(.x) %>% pluck("latitude"))]

#gets p-value
nested_snps[, p_value := purrr::map_dbl(models, 
                                         ~summary(.x) %>% 
                                           pluck("coefficients") %>% pluck(8))]
nested_snps
```

### p-valores

A distribuição dos p-valores ficou assim:
```{r p_value_dist, echo=FALSE, warning = FALSE, message = FALSE}
p_values_97 <- fread("/dados/time_clines/output/SNPs/p-values_97_joined_no_ESC97_mincount5_minfreq0.001_cov15.tsv",
                     skip = 1)
setnames(p_values_97, colnames(p_values_97), c("position2", "coefficients", "p_value"))
p_values_0910 <- fread("/dados/time_clines/output/SNPs/p-values_0910_joined_no_ESC97_mincount5_minfreq0.001_cov15.tsv",
                       skip = 1)
setnames(p_values_0910, colnames(p_values_0910), c("position2", "coefficients", "p_value"))

#finds SNPs that aren't present in that period or that are present in only ------------------------
#one population
#97
freqs_97 <- fread("/dados/time_clines/output/SNPs/joined97_no_ESC97_mincount5_minfreq0.001_cov15.tsv")
freqs_97[, position2 := paste(CHROM, POS, sep = ":")]
freqs_97[, freq_status := 1*(freq!= 0)]
no_0freq_97 <- freqs_97[, .(freq_status_sum = sum(freq_status)), 
                  by = "position2"][freq_status_sum <= 1,]
#2009/2010
freqs_0910 <- fread("/dados/time_clines/output/SNPs/joined0910_no_ESC97_mincount5_minfreq0.001_cov15.tsv")
freqs_0910[, position2 := paste(CHROM, POS, sep = ":")]
freqs_0910[, freq_status := 1*(freq!= 0)]
no_0freq_0910 <- freqs_0910[, .(freq_status_sum = sum(freq_status)), 
                  by = "position2"][freq_status_sum <= 1,]

#filter those SNPs out
p_values_97 <- p_values_97[!no_0freq_97, on = "position2"]
p_values_0910 <- p_values_0910[!no_0freq_0910, on = "position2"]

#plots ------------------ 
plot1 <- p_values_97 %>%
  ggplot() +
  geom_histogram(aes(p_value))+
  labs(x = "p-value", title = "1997",
       caption = "min-freq = 0.001, min-cov = 15, min-count = 5") +
  theme_minimal()

plot2 <- p_values_0910 %>%
  ggplot() +
  geom_histogram(aes(p_value)) +
  labs(x = "p-value", title = "2009/2010",
       caption = "min-freq = 0.001, min-cov = 15, min-count = 5") +
  theme_minimal()

plot1
plot2

```

# Resultados exploratórios

## PCA

Fiz um PCA com os SNPs identificados:

```{r wragle_pca_data, echo=FALSE, message=FALSE}
freqs <- fread("/dados/time_clines/data/seqs/align/NE_no_ESC97_mincount5_minfreq0.001_cov15.tsv")
all_samples <- freqs[, .(population, CHROM, POS, freq)]
all_samples[, position2 := paste(CHROM, POS, sep = ":")]
all_samples2 <- all_samples[, !c("CHROM", "POS")]
pre_pca_table <- dcast.data.table(all_samples2, position2 ~ population,
                                  value.var = "freq")

no_NA_table <- na.omit(pre_pca_table)

pca_table <- no_NA_table %>%
  column_to_rownames(var = "position2")

pca_table <- t(pca_table)

pca <- prcomp(pca_table)
```
```{r variation_pca, echo=FALSE}
pca_var <- pca$sdev^2
pca_var_per <- round(pca_var/sum(pca_var)*100, 1)

```
```{r metadata, echo=FALSE, message=FALSE}
#gets other info that we want
seq_metadata <- read_tsv("/home/vitoria/clinas/seq_metadata.tsv")
pop_info <- seq_metadata %>%
  select(population, collection_year, latitude)

```
```{r pca_plot, echo=FALSE}
graph_table <- tibble(population = rownames(pca$x), 
                  pc1 = pca$x[,1], #gets the first four PCs
                  pc2 = pca$x[,2],
                  pc3 = pca$x[,3],
                  pc4 = pca$x[,4]) %>% 
  inner_join(pop_info, by = "population") %>%  #joins tables
  mutate(collection_year = case_when( #treats collection_year as character
    collection_year == 1997 ~ "1997", 
    collection_year == 2009 ~ "2009/2010", #and join 2009 and 2010
    collection_year == 2010 ~ "2009/2010",
    collection_year == 2017 ~ "2017"
  ))

graph_table %>%
  ggplot(aes(x = pc1, y = pc2)) +
  geom_point(aes(color = latitude), size = 4, alpha = 0.5) +
  scale_color_viridis_c() +
  geom_text(aes(label = population), size = 1.5, nudge_y = 10) +
  xlab(paste("PC1 - ", pca_var_per[1], "%", sep = "")) +
  ylab(paste("PC2 - ", pca_var_per[2], "%", sep = "")) +
  theme_bw()

```

Com PCAs separados por época:

#### 1997

```{r PCA97, echo=FALSE}
pre_pca_table97 <- pre_pca_table[, !(names(pre_pca_table) %like% "09" | names(pre_pca_table) %like% "10" | names(pre_pca_table) %like% "17"),
                                 with = FALSE]

no_NA_table97 <- na.omit(pre_pca_table97)

pca_table97 <- no_NA_table97 %>%
  column_to_rownames(var = "position2")

pca_table97 <- t(pca_table97)

pca97 <- prcomp(pca_table97)

#gets the percentage of variation that each PC accounts
pca_var97 <- pca97$sdev^2
pca_var_per97 <- round(pca_var97/sum(pca_var97)*100, 1)

#joins all info in a single table
graph_table97 <- tibble(population = rownames(pca97$x), 
                      pc1 = pca97$x[,1], #gets the first four PCs
                      pc2 = pca97$x[,2],
                      pc3 = pca97$x[,3],
                      pc4 = pca97$x[,4]) %>% 
  inner_join(pop_info, by = "population") %>%  #joins tables
  mutate(collection_year = as.character(collection_year))


#plot colored by latitude
graph_table97 %>%
  ggplot(aes(x = pc1, y = pc2)) +
  geom_point(aes(color = latitude), size = 4, alpha = 0.5) +
  scale_color_viridis_c() +
  geom_text(aes(label = population), size = 1.5, nudge_y = 10) +
  xlab(paste("PC1 - ", pca_var_per97[1], "%", sep = "")) +
  ylab(paste("PC2 - ", pca_var_per97[2], "%", sep = "")) +
  #labs(title = "1997") +
  theme_bw()

```

#### 2009/2010

```{r PCA0910, echo=FALSE}
pre_pca_table0910 <- pre_pca_table[, !(names(pre_pca_table) %like% "97" | names(pre_pca_table) %like% "17"),
                                 with = FALSE]

no_NA_table0910 <- na.omit(pre_pca_table0910)

pca_table0910 <- no_NA_table0910 %>%
  column_to_rownames(var = "position2")

pca_table0910 <- t(pca_table0910)

pca0910 <- prcomp(pca_table0910)

#gets the percentage of variation that each PC accounts
pca_var0910 <- pca0910$sdev^2
pca_var_per0910 <- round(pca_var0910/sum(pca_var0910)*100, 1)

#joins all info in a single table
graph_table0910 <- tibble(population = rownames(pca0910$x), 
                        pc1 = pca0910$x[,1], #gets the first four PCs
                        pc2 = pca0910$x[,2],
                        pc3 = pca0910$x[,3],
                        pc4 = pca0910$x[,4]) %>% 
  inner_join(pop_info, by = "population") %>%  #joins tables
  mutate(collection_year = as.character(collection_year))


#plot colored by latitude
graph_table0910 %>%
  ggplot(aes(x = pc1, y = pc2)) +
  geom_point(aes(color = latitude), size = 4, alpha = 0.5) +
  scale_color_viridis_c() +
  geom_text(aes(label = population), size = 1.5, nudge_y = 10) +
  xlab(paste("PC1 - ", pca_var_per0910[1], "%", sep = "")) +
  ylab(paste("PC2 - ", pca_var_per0910[2], "%", sep = "")) +
  #labs(title = "2009/2010") +
  theme_bw()
```

## Manhattan Plots

Eu queria ver como esses p-valores estão distribuídos no genoma. Então fiz Manhattan plots para 1997 e 2009/2010.

```{r manhattan_97, echo=FALSE}
p_values_97 <- fread("/dados/time_clines/output/SNPs/p-values_97_joined_no_ESC97_mincount5_minfreq0.001_cov15.tsv")
setnames(p_values_97, colnames(p_values_97), c("position2", "coefficients", "p_value"))
p_values_97[, c("CHROM", "POS") := tstrsplit(position2, ":", fixed = TRUE)]

p_values_97 <- p_values_97[, .(CHROM, POS, p_value)]
p_values_97[, POS := as.double(POS)]
setkey(p_values_97, CHROM)
p_values_97[, ID := .I]

axisdf <-  p_values_97 %>% group_by(CHROM) %>% summarize(center=(max(ID) + min(ID)) / 2 )

#get FDR cutof-----------------
Pvalue_97_cov15 <- p_values_97$p_value
qobj_97_cov15 <- qvalue(p = Pvalue_97_cov15)

#cutoff 10%
p_value_cutoff_0.1 <- max(qobj_97_cov15$pvalues[qobj_97_cov15$qvalues <= 0.1])

#cutoff 1%
p_value_cutoff_0.01 <- max(qobj_97_cov15$pvalues[qobj_97_cov15$qvalues <= 0.01])

#cutoff 5%
p_value_cutoff_0.05 <- max(qobj_97_cov15$pvalues[qobj_97_cov15$qvalues <= 0.05])

##manhattan plot manual------------------

p_values_97 %>%
  ggplot(aes(x = ID, y =-log10(p_value))) +
  geom_point(aes(color=as.factor(CHROM)), alpha=0.8, size=0.9) +
  geom_hline(aes(yintercept = -log10(p_value_cutoff_0.1)), color = "green") +
  geom_hline(aes(yintercept = -log10(p_value_cutoff_0.01)), color = "blue") +
  geom_hline(aes(yintercept = -log10(p_value_cutoff_0.05)), color = "red") +
  geom_text(aes(x = max(ID)+10,
                y = -log10(p_value_cutoff_0.1) + 0.25,
                label = "FDR 10%"),
            size = 2.5, color = "green") +
  geom_text(aes(x = max(ID)+10,
                y = -log10(p_value_cutoff_0.01) + 0.25,
                label = "FDR 1%"),
            size = 2.5, color = "blue") +
  geom_text(aes(x = max(ID)+10,
                y = -log10(p_value_cutoff_0.05) + 0.25,
                label = "FDR 5%"),
            size = 2.5, color = "red") +
  scale_color_manual(values = rep(c("lavender", "lavenderblush1"), 5)) +
  scale_x_continuous(label = axisdf$CHROM, breaks= axisdf$center) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_bw() +
  theme( 
    legend.position="none",
    panel.border = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank()
  ) + 
  labs(title = "1997", y = "-log10(p-value)")

```
```{r manhattan_0910, echo=FALSE}
p_values_0910 <- fread("/dados/time_clines/output/SNPs/p-values_0910_joined_no_ESC97_mincount5_minfreq0.001_cov15.tsv")
setnames(p_values_0910, colnames(p_values_0910), c("position2", "coefficients", "p_value"))

p_values_0910[, c("CHROM", "POS") := tstrsplit(position2, ":", fixed = TRUE)]

p_values_0910 <- p_values_0910[, .(CHROM, POS, p_value)]
p_values_0910[, POS := as.double(POS)]
setkey(p_values_0910, CHROM)
p_values_0910[, ID := .I]

axisdf <-  p_values_0910 %>% group_by(CHROM) %>% summarize(center=( max(ID) + min(ID) ) / 2 )

#get FDR cutof-------
Pvalue_0910_cov15 <- p_values_0910$p_value
qobj_0910_cov15 <- qvalue(p = Pvalue_0910_cov15)

#cutoff 10%
p_value_cutoff_0.1 <- max(qobj_0910_cov15$pvalues[qobj_0910_cov15$qvalues <= 0.1])

#cutoff 1%
p_value_cutoff_0.01 <- max(qobj_0910_cov15$pvalues[qobj_0910_cov15$qvalues <= 0.01])

#cutoff 5%
p_value_cutoff_0.05 <- max(qobj_0910_cov15$pvalues[qobj_0910_cov15$qvalues <= 0.05])

#manhattan plot manual----------

p_values_0910 %>%
  ggplot(aes(x = ID, y =-log10(p_value))) +
  geom_point(aes(color=as.factor(CHROM)), alpha=0.8, size=0.9) +
  geom_hline(aes(yintercept = -log10(p_value_cutoff_0.1)), color = "green") +
  geom_hline(aes(yintercept = -log10(p_value_cutoff_0.01)), color = "blue") +
  geom_hline(aes(yintercept = -log10(p_value_cutoff_0.05)), color = "red") +
  geom_text(aes(x = max(ID)+10,
                y = -log10(p_value_cutoff_0.1) + 0.25,
                label = "FDR 10%"),
            size = 2.5, color = "green") +
  geom_text(aes(x = max(ID)+10,
                y = -log10(p_value_cutoff_0.01) + 0.25,
                label = "FDR 1%"),
            size = 2.5, color = "blue") +
  geom_text(aes(x = max(ID)+10,
                y = -log10(p_value_cutoff_0.05) + 0.25,
                label = "FDR 5%"),
            size = 2.5, color = "red") +
  scale_color_manual(values = rep(c("lavender", "lavenderblush1"), 5)) +
  scale_x_continuous(label = axisdf$CHROM, breaks= axisdf$center) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_bw() +
  theme( 
    legend.position="none",
    panel.border = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank()
  ) + 
  labs(title = "2009/2010", y = "-log10(p-value)")
```

## Inversões

Pelo gráfico anterior deu para perceber que a região do 3R tem mais SNPs clinais que as demais. Então usei o pipeline descrito em Kapun et al. 2014 (usando inclusive os mesmos scripts) para calcular as frequências das inversões.

```{r inversions, echo=FALSE, message=FALSE, warning=FALSE}
inv_freq <- fread("/dados/vitoria/invertions_freqs/PoolSNP_no_ESC97_mincount5_minfreq0.001_cov15_inversion.freq")

inv_freq <- melt.data.table(inv_freq, measure.vars =  2:14,
                            variable.name = "population",
                            value.name = "freq")

complete <- inv_freq %>%
  inner_join(pop_info, by = "population") %>%
  mutate(collection_year = case_when( #treats collection_year as character
    collection_year == 1997 ~ "1997", 
    collection_year == 2009 ~ "2009/2010", #and join 2009 and 2010
    collection_year == 2010 ~ "2009/2010",
    collection_year == 2017 ~ "2017"
  ))
complete %>%
  filter(collection_year != "2017") %>%
  ggplot(aes(x = latitude, y = freq)) +
  geom_point(aes(color = collection_year), alpha = 0.5) +
  geom_smooth(aes(color = collection_year), method = 'lm', alpha = 0.2) +
  geom_text(aes(label = population), size = 1.5, nudge_y = 0.07) +
  facet_wrap(~ Inv, nrow = 3) +
  theme_light() +
  labs(title = "Inversions Frequencies") +
  scale_fill_discrete(name = "Collection Year")

```

## PCA with African and European samples

Peguei duas populações do DGN (Drosophila Genome Nexus), uma Africana (da Zâmbia) e outra Europeia (da França). Refiz o PCA com essas amostras.

```{r pca_dgn, echo=FALSE}
pre_pca_dgn <- fread("/dados/vitoria/pre_pca_dgn.tsv")

pop_info <- pop_info %>% add_row(population = c("FR10", "ZI10"),
                     collection_year = 2010,
                     latitude = NA)

pre_pca_dgn <- t(pre_pca_dgn)

pca_dgn<- prcomp(pre_pca_dgn)

#gets the percentage of variation that each PC accounts
pca_var_dgn <- pca_dgn$sdev^2
pca_var_per_dgn <- round(pca_var_dgn/sum(pca_var_dgn)*100, 1)

#joins all info in a single table
graph_table_dgn <- tibble(population = rownames(pca_dgn$x), 
                          pc1 = pca_dgn$x[,1], #gets the first four PCs
                          pc2 = pca_dgn$x[,2],
                          pc3 = pca_dgn$x[,3],
                          pc4 = pca_dgn$x[,4]) %>% 
  inner_join(pop_info, by = "population") %>%  #joins tables
  mutate(collection_year = as.character(collection_year))


#plot colored by latitude
graph_table_dgn %>%
  ggplot(aes(x = pc1, y = pc2)) +
  geom_point(aes(color = latitude), size = 4, alpha = 0.5) +
  scale_color_viridis_c() +
  geom_text(aes(label = population), size = 1.5, nudge_y = 10) +
  xlab(paste("PC1 - ", pca_var_per_dgn[1], "%", sep = "")) +
  ylab(paste("PC2 - ", pca_var_per_dgn[2], "%", sep = "")) +
  #labs(title = "1997") +
  theme_bw()

```

## Enrichment analysis

Para entender se havia algum enriquecida para SNPs clinais, anotamos todos os SNPs identificados com [snpEff](). Isso foi feito com o seguinte comando:

```{bash annotation, eval=F, echo=T}
java -Xmx8g -jar /home/vitoria/bin/snpEff/snpEff.jar BDGP6.32.105 {input} > {output}

```

O snpEff anota varios efeitos por SNP e os ordena por impacto, com o efeito de maior impacto primeiro. Como não daria par aanalizar todos os efeitos, fiquei apenas com o efeito de maior impacto de cada SNP. Isso foi feito nesse [script](). 
Os SNPs clinais estavam distribuidos assim:

```{r SNP_distribuition, echo=FALSE}
clinal_status <- fread("/dados/time_clines/output/SNPs/clinal_and_effect_status_fdr0.1.tsv")
tiny_clinal_status <- clinal_status[!(effect %in% c("START_GAINED", "STOP_GAINED",
                                               "SYNONYMOUS_STOP", "START_LOST",
                                               "STOP_LOST",
                                               "NON_SYNONYMOUS_START",
                                               "SPLICE",
                                               "NON_CODING_TRANSCRIPT"))]

tiny_clinal_status %>%
  ggplot() +
  geom_bar(aes(y = effect, fill = clinal97)) +
  labs(title = "1997") +
  theme_light() +
  theme(plot.title = element_text(size=18))

tiny_clinal_status %>%
  ggplot() +
  geom_bar(aes(y = effect, fill = clinal97), position = "fill") +
  labs(title = "1997") +
  theme_light() +
  theme(plot.title = element_text(size=18))

tiny_clinal_status %>%
  ggplot() +
  geom_bar(aes(y = effect, fill = clinal0910)) +
  labs(title = "2009/2010") +
  theme_light() +
  theme(plot.title = element_text(size=18))

tiny_clinal_status %>%
  ggplot() +
  geom_bar(aes(y = effect, fill = clinal0910), position = "fill") +
  labs(title = "2009/2010") +
  theme_light() +
  theme(plot.title = element_text(size=18))

```

Em seguida, montei a sequinte tabela:

```{r clinal_status_table, echo=FALSE}
tiny_clinal_status <- tiny_clinal_status[CHROM == "2L"]
tiny_clinal_status[, a := 1]
dcasted_tiny_clinal_status <- 
  dcast(tiny_clinal_status, CHROM + POS + clinal97 + clinal0910 + REF + ALT + ANN + region ~ effect,
        value.var = "a", fill = 0)
kable(dcasted_tiny_clinal_status[1:10])
```

Antes de continuar com as análises de enriquecimento, eu exclui alguns SNPs com algumas anotações, dentre elas: start_gained, stop_gained, synonymous_stop, start_lost, stop_lost, non_synonymous_start, splice e non_coding_transcript.
                                               
Para obter o odds ratio para cada efeito rodei uma regressão logistica do status clinal (nesse caso, usei FDR 0.1) em relação ao efeito

```{r formula_logistic, eval=FALSE, echo=TRUE}
models <- foreach(i = 1:n_effects) %dopar% {
  glm(data = dcasted_tiny_clinal_status,
      paste(clinal_year," ~ ", EFFECTS[[i]]),
      family = binomial)
}
```

A ideia era comparar a chance do SNP ser clinal dentre os SNPs de um determinado efeito com a chance do SNP ser clinal dentre todas os outros efeitos:

$$
log(\frac{UPSTREAM \& Clinal}{UPSTREAM \& Not Clinal}) - log(\frac{Not UPSTREAM \& Clinal}{Not UPSTREAM \& Not Clinal})
$$

Um exemplo com apenas SNPs no cromossomo 2L de um desses modelos:

```{r ex_model_logistic, echo=FALSE}
dcasted_tiny_clinal_status[, UPSTREAM := as.factor(UPSTREAM)]
dcasted_tiny_clinal_status[, clinal0910 := as.factor(clinal0910)]

ex_model <- glm(data = dcasted_tiny_clinal_status,
      clinal0910  ~ UPSTREAM,
      family = binomial)
summary(ex_model)

```
Em seguida usei bootstrap para obter os intervalos de confiança:

```{r bootstrap_formula, eval=FALSE, echo=TRUE}
intervals_percentile <- foreach(i = 1:n_effects) %dopar% {
  reg_intervals(paste(clinal_year," ~ ", EFFECTS[[i]]),
                data = dcasted_tiny_clinal_status,
                model_fn = "glm",
                family = binomial,
                keep_reps = TRUE,
                type = "percentile")
}
```
```{r regression_plots_setup, echo=FALSE}
tibble_intervals_0910 <- fread("/dados/time_clines/output/SNPs/bootstrap_replicas_fdr0.1_0910.tsv")
tibble_intervals_97 <- fread("/dados/time_clines/output/SNPs/bootstrap_replicas_fdr0.1_97.tsv")

odds_ratio_effects0910 <- fread("/dados/time_clines/output/SNPs/odd_ratio_effects_fdr0.1_0910.tsv")
odds_ratio_effects97 <- fread("/dados/time_clines/output/SNPs/odd_ratio_effects_fdr0.1_97.tsv")

```
```{r odds_ratio_97, echo=FALSE, warning=FALSE, message=FALSE}
tibble_intervals_97[, term := str_remove(term, "1")]

coefficients_table <- odds_ratio_effects97[,.(effects, coefficients)]
setkey(coefficients_table, effects)  
setkey(tibble_intervals_97, term)
tibble_intervals_97 <- coefficients_table[tibble_intervals_97]

tibble_intervals_97 %>%
  ggplot(aes(estimate, fill = effects)) +
  geom_vline(xintercept = 0, lty = 2, color = "gray50") +
  geom_vline(aes(xintercept = .lower), color = "red") +
  geom_vline(aes(xintercept = .upper), color = "red") +
  geom_vline(aes(xintercept = .estimate), color = "green") +
  geom_vline(aes(xintercept = coefficients), color = "black") +
  geom_histogram(alpha = 0.8, show.legend = FALSE) +
  facet_wrap(~effects, scales = "free") +
  labs(caption = "Bootstrap replicates distribution.
       Red lines show confidence interval for 95% using percentile method.
       Grey lines show bootstrap estimate and green lines model coefficient",
       title = "1997")

ggplot(odds_ratio_effects97, aes(x = coefficients, y = effects)) +
  geom_vline(aes(xintercept = 0), linetype = "dashed") +
  geom_errorbar(aes(xmax = ci_upper_perc, xmin = ci_lower_perc), 
                size = 0.5,
                width = 0.2,
                color = "grey50") +
  geom_point(size = 3.5, color = "mediumorchid") +
  #geom_point(aes(x = bt_estimate_perc, y = effects), size = 3.5, color = "red") +
  theme_bw() +
  ylab("") +
  xlab("Log Odds Ratio") +
  ggtitle("Enrichment of clinal SNPs in 1997")

```
```{r odds_ratio_0910, echo=FALSE, warning=FALSE, message=FALSE}
tibble_intervals_0910[, term := str_remove(term, "1")]

coefficients_table <- odds_ratio_effects0910[,.(effects, coefficients)]
setkey(coefficients_table, effects)  
setkey(tibble_intervals_0910, term)
tibble_intervals_0910 <- coefficients_table[tibble_intervals_0910]

tibble_intervals_0910 %>%
  ggplot(aes(estimate, fill = effects)) +
  geom_vline(xintercept = 0, lty = 2, color = "gray50") +
  geom_vline(aes(xintercept = .lower), color = "red") +
  geom_vline(aes(xintercept = .upper), color = "red") +
  geom_vline(aes(xintercept = .estimate), color = "green") +
  geom_vline(aes(xintercept = coefficients), color = "black") +
  geom_histogram(alpha = 0.8, show.legend = FALSE) +
  facet_wrap(~effects, scales = "free") +
  labs(caption = "Bootstrap replicates distribution.
       Red lines show confidence interval for 95% using percentile method.
       Grey lines show bootstrap estimate and green lines model coefficient",
       title = "2009/2010")

ggplot(odds_ratio_effects0910, aes(x = coefficients, y = effects)) +
  geom_vline(aes(xintercept = 0), linetype = "dashed") +
  geom_errorbar(aes(xmax = ci_upper_perc, xmin = ci_lower_perc), 
                size = 0.5,
                width = 0.2,
                color = "grey50") +
  geom_point(size = 3.5, color = "mediumorchid") +
  #geom_point(aes(x = bt_estimate_perc, y = effects), size = 3.5, color = "red") +
  theme_bw() +
  ylab("") +
  xlab("Log Odds Ratio") +
  ggtitle("Enrichment of clinal SNPs in 2009/2010")

```
